{
  "ast": null,
  "code": "import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport XDate from 'xdate';\nimport constants from \"../commons/constants\";\nimport inRange from 'lodash/inRange';\nexport var HOUR_BLOCK_HEIGHT = 100;\nvar OVERLAP_EVENTS_SPACINGS = 10;\nvar RIGHT_EDGE_SPACING = 10;\n\nfunction buildEvent(event, left, width, _ref) {\n  var _ref$dayStart = _ref.dayStart,\n      dayStart = _ref$dayStart === void 0 ? 0 : _ref$dayStart,\n      _ref$hourBlockHeight = _ref.hourBlockHeight,\n      hourBlockHeight = _ref$hourBlockHeight === void 0 ? HOUR_BLOCK_HEIGHT : _ref$hourBlockHeight;\n  var startTime = new XDate(event.start);\n  var endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n  var dayStartTime = new XDate(startTime).clearTime();\n  return _objectSpread(_objectSpread({}, event), {}, {\n    top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n    height: startTime.diffHours(endTime) * hourBlockHeight,\n    width: width,\n    left: left\n  });\n}\n\nfunction hasCollision(a, b) {\n  return a.end > b.start && a.start < b.end;\n}\n\nfunction calcColumnSpan(event, columnIndex, columns) {\n  var colSpan = 1;\n\n  for (var i = columnIndex + 1; i < columns.length; i++) {\n    var column = columns[i];\n    var foundCollision = column.find(function (ev) {\n      return hasCollision(event, ev);\n    });\n\n    if (foundCollision) {\n      return colSpan;\n    }\n\n    colSpan++;\n  }\n\n  return colSpan;\n}\n\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n  var _populateOptions$scre = populateOptions.screenWidth,\n      screenWidth = _populateOptions$scre === void 0 ? constants.screenWidth : _populateOptions$scre,\n      _populateOptions$righ = populateOptions.rightEdgeSpacing,\n      rightEdgeSpacing = _populateOptions$righ === void 0 ? RIGHT_EDGE_SPACING : _populateOptions$righ,\n      _populateOptions$over = populateOptions.overlapEventsSpacing,\n      overlapEventsSpacing = _populateOptions$over === void 0 ? OVERLAP_EVENTS_SPACINGS : _populateOptions$over;\n  columns.forEach(function (column, columnIndex) {\n    column.forEach(function (event) {\n      var totalWidth = screenWidth - rightEdgeSpacing;\n      var columnSpan = calcColumnSpan(event, columnIndex, columns);\n      var eventLeft = columnIndex / columns.length * totalWidth;\n      var eventWidth = totalWidth * (columnSpan / columns.length);\n\n      if (columnIndex + columnSpan <= columns.length - 1) {\n        eventWidth -= overlapEventsSpacing;\n      }\n\n      calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n    });\n  });\n}\n\nexport function populateEvents(_events, populateOptions) {\n  var lastEnd = null;\n  var columns = [];\n  var calculatedEvents = [];\n\n  var events = _events.map(function (ev, index) {\n    return _objectSpread(_objectSpread({}, ev), {}, {\n      index: index\n    });\n  }).sort(function (a, b) {\n    if (a.start < b.start) return -1;\n    if (a.start > b.start) return 1;\n    if (a.end < b.end) return -1;\n    if (a.end > b.end) return 1;\n    return 0;\n  });\n\n  events.forEach(function (ev) {\n    if (lastEnd !== null && ev.start >= lastEnd) {\n      packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n      columns = [];\n      lastEnd = null;\n    }\n\n    var placed = false;\n\n    for (var i = 0; i < columns.length; i++) {\n      var col = columns[i];\n\n      if (!hasCollision(col[col.length - 1], ev)) {\n        col.push(ev);\n        placed = true;\n        break;\n      }\n    }\n\n    if (!placed) {\n      columns.push([ev]);\n    }\n\n    if (lastEnd === null || ev.end > lastEnd) {\n      lastEnd = ev.end;\n    }\n  });\n\n  if (columns.length > 0) {\n    packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n  }\n\n  return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks() {\n  var unavailableHours = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 ? arguments[1] : undefined;\n\n  var _ref2 = options || {},\n      _ref2$hourBlockHeight = _ref2.hourBlockHeight,\n      hourBlockHeight = _ref2$hourBlockHeight === void 0 ? HOUR_BLOCK_HEIGHT : _ref2$hourBlockHeight,\n      _ref2$dayStart = _ref2.dayStart,\n      dayStart = _ref2$dayStart === void 0 ? 0 : _ref2$dayStart,\n      _ref2$dayEnd = _ref2.dayEnd,\n      dayEnd = _ref2$dayEnd === void 0 ? 24 : _ref2$dayEnd;\n\n  var totalDayHours = dayEnd - dayStart;\n  var totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n  return unavailableHours.map(function (hours) {\n    if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n      console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n      return undefined;\n    }\n\n    if (hours.start >= hours.end) {\n      console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n      return undefined;\n    }\n\n    var startFixed = Math.max(hours.start, dayStart);\n    var endFixed = Math.min(hours.end, dayEnd);\n    return {\n      top: (startFixed - dayStart) / totalDayHours * totalDayHeight,\n      height: (endFixed - startFixed) * hourBlockHeight\n    };\n  }).filter(Boolean);\n}",
  "map": {
    "version": 3,
    "names": [
      "XDate",
      "constants",
      "inRange",
      "HOUR_BLOCK_HEIGHT",
      "OVERLAP_EVENTS_SPACINGS",
      "RIGHT_EDGE_SPACING",
      "buildEvent",
      "event",
      "left",
      "width",
      "dayStart",
      "hourBlockHeight",
      "startTime",
      "start",
      "endTime",
      "end",
      "addHours",
      "dayStartTime",
      "clearTime",
      "top",
      "diffHours",
      "height",
      "hasCollision",
      "a",
      "b",
      "calcColumnSpan",
      "columnIndex",
      "columns",
      "colSpan",
      "i",
      "length",
      "column",
      "foundCollision",
      "find",
      "ev",
      "packOverlappingEventGroup",
      "calculatedEvents",
      "populateOptions",
      "screenWidth",
      "rightEdgeSpacing",
      "overlapEventsSpacing",
      "forEach",
      "totalWidth",
      "columnSpan",
      "eventLeft",
      "eventWidth",
      "push",
      "populateEvents",
      "_events",
      "lastEnd",
      "events",
      "map",
      "index",
      "sort",
      "placed",
      "col",
      "buildUnavailableHoursBlocks",
      "unavailableHours",
      "options",
      "dayEnd",
      "totalDayHours",
      "totalDayHeight",
      "hours",
      "console",
      "error",
      "undefined",
      "startFixed",
      "Math",
      "max",
      "endFixed",
      "min",
      "filter",
      "Boolean"
    ],
    "sources": [
      "D:/repos/DFMPC-Student-Placement-System/node_modules/react-native-calendars/src/timeline/Packer.js"
    ],
    "sourcesContent": [
      "// @flow\nimport XDate from 'xdate';\nimport constants from '../commons/constants';\nimport inRange from 'lodash/inRange';\nexport const HOUR_BLOCK_HEIGHT = 100;\nconst OVERLAP_EVENTS_SPACINGS = 10;\nconst RIGHT_EDGE_SPACING = 10;\nfunction buildEvent(event, left, width, { dayStart = 0, hourBlockHeight = HOUR_BLOCK_HEIGHT }) {\n    const startTime = new XDate(event.start);\n    const endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n    const dayStartTime = new XDate(startTime).clearTime();\n    return {\n        ...event,\n        top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n        height: startTime.diffHours(endTime) * hourBlockHeight,\n        width,\n        left\n    };\n}\nfunction hasCollision(a, b) {\n    return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n    let colSpan = 1;\n    for (let i = columnIndex + 1; i < columns.length; i++) {\n        const column = columns[i];\n        const foundCollision = column.find(ev => hasCollision(event, ev));\n        if (foundCollision) {\n            return colSpan;\n        }\n        colSpan++;\n    }\n    return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n    const { screenWidth = constants.screenWidth, rightEdgeSpacing = RIGHT_EDGE_SPACING, overlapEventsSpacing = OVERLAP_EVENTS_SPACINGS } = populateOptions;\n    columns.forEach((column, columnIndex) => {\n        column.forEach(event => {\n            const totalWidth = screenWidth - rightEdgeSpacing;\n            const columnSpan = calcColumnSpan(event, columnIndex, columns);\n            const eventLeft = (columnIndex / columns.length) * totalWidth;\n            let eventWidth = totalWidth * (columnSpan / columns.length);\n            if (columnIndex + columnSpan <= columns.length - 1) {\n                eventWidth -= overlapEventsSpacing;\n            }\n            calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n        });\n    });\n}\nexport function populateEvents(_events, populateOptions) {\n    let lastEnd = null;\n    let columns = [];\n    const calculatedEvents = [];\n    const events = _events\n        .map((ev, index) => ({ ...ev, index: index }))\n        .sort(function (a, b) {\n        if (a.start < b.start)\n            return -1;\n        if (a.start > b.start)\n            return 1;\n        if (a.end < b.end)\n            return -1;\n        if (a.end > b.end)\n            return 1;\n        return 0;\n    });\n    events.forEach(function (ev) {\n        // Reset recent overlapping event group and start a new one\n        if (lastEnd !== null && ev.start >= lastEnd) {\n            packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n            columns = [];\n            lastEnd = null;\n        }\n        // Place current event in the right column where it doesn't overlap\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (!hasCollision(col[col.length - 1], ev)) {\n                col.push(ev);\n                placed = true;\n                break;\n            }\n        }\n        // If curr event wasn't placed in any of the columns, create a new column for it\n        if (!placed) {\n            columns.push([ev]);\n        }\n        if (lastEnd === null || ev.end > lastEnd) {\n            lastEnd = ev.end;\n        }\n    });\n    if (columns.length > 0) {\n        packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n    }\n    return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks(unavailableHours = [], options) {\n    const { hourBlockHeight = HOUR_BLOCK_HEIGHT, dayStart = 0, dayEnd = 24 } = options || {};\n    const totalDayHours = dayEnd - dayStart;\n    const totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n    return (unavailableHours\n        .map(hours => {\n        if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n            console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n            return undefined;\n        }\n        if (hours.start >= hours.end) {\n            console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n            return undefined;\n        }\n        const startFixed = Math.max(hours.start, dayStart);\n        const endFixed = Math.min(hours.end, dayEnd);\n        return {\n            top: ((startFixed - dayStart) / totalDayHours) * totalDayHeight,\n            height: (endFixed - startFixed) * hourBlockHeight\n        };\n    })\n        // Note: this filter falsy values (undefined blocks)\n        .filter(Boolean));\n}\n"
    ],
    "mappings": "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"
  },
  "metadata": {},
  "sourceType": "module"
}
