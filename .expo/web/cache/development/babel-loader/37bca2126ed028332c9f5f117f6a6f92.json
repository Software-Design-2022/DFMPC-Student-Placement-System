{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport { setAutoServerRegistrationEnabledAsync } from \"./DevicePushTokenAutoRegistration.fx\";\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nvar productionBaseUrl = 'https://exp.host/--/api/v2/';\nexport default function getExpoPushTokenAsync() {\n  var _Constants$manifest, _Constants$manifest2, _Constants$manifest2$, _Constants$manifest2$2, _Constants$manifest3, _Constants$manifest4, _Constants$manifest4$, _Constants$manifest4$2, _Constants$manifest5, _options$baseUrl, _options$url;\n\n  var options,\n      devicePushToken,\n      deviceId,\n      experienceId,\n      projectId,\n      applicationId,\n      type,\n      development,\n      baseUrl,\n      url,\n      body,\n      response,\n      statusInfo,\n      _body,\n      expoPushToken,\n      _args = arguments;\n\n  return _regeneratorRuntime.async(function getExpoPushTokenAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n          _context.t0 = options.devicePushToken;\n\n          if (_context.t0) {\n            _context.next = 6;\n            break;\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(getDevicePushTokenAsync());\n\n        case 5:\n          _context.t0 = _context.sent;\n\n        case 6:\n          devicePushToken = _context.t0;\n          _context.t1 = options.deviceId;\n\n          if (_context.t1) {\n            _context.next = 12;\n            break;\n          }\n\n          _context.next = 11;\n          return _regeneratorRuntime.awrap(getDeviceIdAsync());\n\n        case 11:\n          _context.t1 = _context.sent;\n\n        case 12:\n          deviceId = _context.t1;\n          experienceId = options.experienceId || ((_Constants$manifest = Constants.manifest) == null ? void 0 : _Constants$manifest.originalFullName) || ((_Constants$manifest2 = Constants.manifest2) == null ? void 0 : (_Constants$manifest2$ = _Constants$manifest2.extra) == null ? void 0 : (_Constants$manifest2$2 = _Constants$manifest2$.expoClient) == null ? void 0 : _Constants$manifest2$2.originalFullName) || ((_Constants$manifest3 = Constants.manifest) == null ? void 0 : _Constants$manifest3.id);\n          projectId = options.projectId || ((_Constants$manifest4 = Constants.manifest2) == null ? void 0 : (_Constants$manifest4$ = _Constants$manifest4.extra) == null ? void 0 : (_Constants$manifest4$2 = _Constants$manifest4$.eas) == null ? void 0 : _Constants$manifest4$2.projectId) || ((_Constants$manifest5 = Constants.manifest) == null ? void 0 : _Constants$manifest5.projectId);\n\n          if (!(!experienceId && !projectId)) {\n            _context.next = 17;\n            break;\n          }\n\n          throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID', \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\");\n\n        case 17:\n          applicationId = options.applicationId || Application.applicationId;\n\n          if (applicationId) {\n            _context.next = 20;\n            break;\n          }\n\n          throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID', \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");\n\n        case 20:\n          type = options.type || getTypeOfToken(devicePushToken);\n          _context.t2 = options.development;\n\n          if (_context.t2) {\n            _context.next = 26;\n            break;\n          }\n\n          _context.next = 25;\n          return _regeneratorRuntime.awrap(shouldUseDevelopmentNotificationService());\n\n        case 25:\n          _context.t2 = _context.sent;\n\n        case 26:\n          development = _context.t2;\n          baseUrl = (_options$baseUrl = options.baseUrl) != null ? _options$baseUrl : productionBaseUrl;\n          url = (_options$url = options.url) != null ? _options$url : baseUrl + \"push/getExpoPushToken\";\n          body = _objectSpread({\n            type: type,\n            deviceId: deviceId.toLowerCase(),\n            development: development,\n            appId: applicationId,\n            deviceToken: getDeviceToken(devicePushToken)\n          }, projectId ? {\n            projectId: projectId\n          } : {\n            experienceId: experienceId\n          });\n          _context.next = 32;\n          return _regeneratorRuntime.awrap(fetch(url, {\n            method: 'POST',\n            headers: {\n              'content-type': 'application/json'\n            },\n            body: JSON.stringify(body)\n          }).catch(function (error) {\n            throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR', \"Error encountered while fetching Expo token: \" + error + \".\");\n          }));\n\n        case 32:\n          response = _context.sent;\n\n          if (response.ok) {\n            _context.next = 45;\n            break;\n          }\n\n          statusInfo = response.statusText || response.status;\n          _body = undefined;\n          _context.prev = 36;\n          _context.next = 39;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 39:\n          _body = _context.sent;\n          _context.next = 44;\n          break;\n\n        case 42:\n          _context.prev = 42;\n          _context.t3 = _context[\"catch\"](36);\n\n        case 44:\n          throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Error encountered while fetching Expo token, expected an OK response, received: \" + statusInfo + \" (body: \\\"\" + _body + \"\\\").\");\n\n        case 45:\n          _context.t4 = getExpoPushToken;\n          _context.next = 48;\n          return _regeneratorRuntime.awrap(parseResponse(response));\n\n        case 48:\n          _context.t5 = _context.sent;\n          expoPushToken = (0, _context.t4)(_context.t5);\n          _context.prev = 50;\n\n          if (!(options.url || options.baseUrl)) {\n            _context.next = 55;\n            break;\n          }\n\n          console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");\n          _context.next = 57;\n          break;\n\n        case 55:\n          _context.next = 57;\n          return _regeneratorRuntime.awrap(setAutoServerRegistrationEnabledAsync(true));\n\n        case 57:\n          _context.next = 62;\n          break;\n\n        case 59:\n          _context.prev = 59;\n          _context.t6 = _context[\"catch\"](50);\n          console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service', _context.t6);\n\n        case 62:\n          return _context.abrupt(\"return\", {\n            type: 'expo',\n            data: expoPushToken\n          });\n\n        case 63:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[36, 42], [50, 59]], Promise);\n}\n\nfunction parseResponse(response) {\n  return _regeneratorRuntime.async(function parseResponse$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(response.json());\n\n        case 3:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 6:\n          _context2.prev = 6;\n          _context2.t0 = _context2[\"catch\"](0);\n          _context2.prev = 8;\n          _context2.t1 = CodedError;\n          _context2.t2 = JSON;\n          _context2.next = 13;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 13:\n          _context2.t3 = _context2.sent;\n          _context2.t4 = _context2.t2.stringify.call(_context2.t2, _context2.t3);\n          _context2.t5 = \"Expected a JSON response from server when fetching Expo token, received body: \" + _context2.t4;\n          _context2.t6 = _context2.t5 + \".\";\n          throw new _context2.t1('ERR_NOTIFICATIONS_SERVER_ERROR', _context2.t6);\n\n        case 20:\n          _context2.prev = 20;\n          _context2.t7 = _context2[\"catch\"](8);\n          throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received response: \" + JSON.stringify(response) + \".\");\n\n        case 23:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[0, 6], [8, 20]], Promise);\n}\n\nfunction getExpoPushToken(data) {\n  if (!data || !(typeof data === 'object') || !data.data || !(typeof data.data === 'object') || !data.data.expoPushToken || !(typeof data.data.expoPushToken === 'string')) {\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \" + JSON.stringify(data, null, 2) + \".\");\n  }\n\n  return data.data.expoPushToken;\n}\n\nfunction getDeviceIdAsync() {\n  return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n\n          if (ServerRegistrationModule.getInstallationIdAsync) {\n            _context3.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n\n        case 3:\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());\n\n        case 5:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 8:\n          _context3.prev = 8;\n          _context3.t0 = _context3[\"catch\"](0);\n          throw new CodedError('ERR_NOTIF_DEVICE_ID', \"Could not have fetched installation ID of the application: \" + _context3.t0 + \".\");\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\n\nfunction getDeviceToken(devicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\nfunction shouldUseDevelopmentNotificationService() {\n  var notificationServiceEnvironment;\n  return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!(Platform.OS === 'ios')) {\n            _context4.next = 11;\n            break;\n          }\n\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());\n\n        case 4:\n          notificationServiceEnvironment = _context4.sent;\n\n          if (!(notificationServiceEnvironment === 'development')) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", true);\n\n        case 7:\n          _context4.next = 11;\n          break;\n\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](1);\n\n        case 11:\n          return _context4.abrupt(\"return\", false);\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 9]], Promise);\n}\n\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n\n    case 'android':\n      return 'fcm';\n\n    default:\n      return devicePushToken.type;\n  }\n}","map":{"version":3,"mappings":"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","names":["Application","Constants","Platform","CodedError","UnavailabilityError","setAutoServerRegistrationEnabledAsync","ServerRegistrationModule","getDevicePushTokenAsync","productionBaseUrl","getExpoPushTokenAsync","options","devicePushToken","deviceId","getDeviceIdAsync","experienceId","manifest","originalFullName","manifest2","extra","expoClient","id","projectId","eas","applicationId","type","getTypeOfToken","development","shouldUseDevelopmentNotificationService","baseUrl","url","body","toLowerCase","appId","deviceToken","getDeviceToken","fetch","method","headers","JSON","stringify","catch","error","response","ok","statusInfo","statusText","status","undefined","text","getExpoPushToken","parseResponse","expoPushToken","console","debug","warn","data","json","getInstallationIdAsync","OS","getIosPushNotificationServiceEnvironmentAsync","notificationServiceEnvironment"],"sourceRoot":"","sources":["../src/getExpoPushTokenAsync.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\ninterface Options {\n  // Endpoint URL override\n  baseUrl?: string;\n\n  // Request URL override\n  url?: string;\n\n  // Request body overrides\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  projectId?: string;\n  applicationId?: string;\n  devicePushToken?: DevicePushToken;\n}\n\nexport default async function getExpoPushTokenAsync(options: Options = {}): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId ||\n    Constants.manifest?.originalFullName ||\n    Constants.manifest2?.extra?.expoClient?.originalFullName ||\n    Constants.manifest?.id;\n\n  const projectId =\n    options.projectId ||\n    Constants.manifest2?.extra?.eas?.projectId ||\n    Constants.manifest?.projectId;\n\n  if (!experienceId && !projectId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    ...(projectId ? { projectId } : { experienceId }),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch((error) => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch (error) {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch (error) {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch (innerError) {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}