{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { EventEmitter, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport NotificationsHandlerModule from \"./NotificationsHandlerModule\";\nexport var NotificationTimeoutError = function (_CodedError) {\n  _inherits(NotificationTimeoutError, _CodedError);\n  var _super = _createSuper(NotificationTimeoutError);\n  function NotificationTimeoutError(notificationId, notification) {\n    var _this;\n    _classCallCheck(this, NotificationTimeoutError);\n    _this = _super.call(this, 'ERR_NOTIFICATION_TIMEOUT', \"Notification handling timed out for ID \" + notificationId + \".\");\n    _this.info = {\n      id: notificationId,\n      notification: notification\n    };\n    return _this;\n  }\n  return _createClass(NotificationTimeoutError);\n}(CodedError);\nvar notificationEmitter = new EventEmitter(NotificationsHandlerModule);\nvar handleNotificationEventName = 'onHandleNotification';\nvar handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\nvar handleSubscription = null;\nvar handleTimeoutSubscription = null;\nexport function setNotificationHandler(handler) {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener(handleNotificationEventName, function _callee(_ref) {\n      var id, notification, behavior;\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = _ref.id, notification = _ref.notification;\n              if (NotificationsHandlerModule.handleNotificationAsync) {\n                _context.next = 4;\n                break;\n              }\n              handler.handleError == null ? void 0 : handler.handleError(id, new UnavailabilityError('Notifications', 'handleNotificationAsync'));\n              return _context.abrupt(\"return\");\n            case 4:\n              _context.prev = 4;\n              _context.next = 7;\n              return _regeneratorRuntime.awrap(handler.handleNotification(notification));\n            case 7:\n              behavior = _context.sent;\n              _context.next = 10;\n              return _regeneratorRuntime.awrap(NotificationsHandlerModule.handleNotificationAsync(id, behavior));\n            case 10:\n              handler.handleSuccess == null ? void 0 : handler.handleSuccess(id);\n              _context.next = 16;\n              break;\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](4);\n              handler.handleError == null ? void 0 : handler.handleError(id, _context.t0);\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[4, 13]], Promise);\n    });\n    handleTimeoutSubscription = notificationEmitter.addListener(handleNotificationTimeoutEventName, function (_ref2) {\n      var id = _ref2.id,\n        notification = _ref2.notification;\n      return handler.handleError == null ? void 0 : handler.handleError(id, new NotificationTimeoutError(id, notification));\n    });\n  }\n}","map":{"version":3,"mappings":";;;;;;;;AAAA,SAASA,YAAY,EAAgBC,UAAU,EAAEC,mBAAmB,QAAQ,mBAAmB;AAG/F,OAAOC,0BAA0B;AAEjC,WAAaC,wBAAyB;EAAA;EAAA;EAEpC,kCAAYC,cAAsB,EAAEC,YAA0B;IAAA;IAAA;IAC5D,0BAAM,0BAA0B,8CAA4CD,cAAc;IAC1F,MAAKE,IAAI,GAAG;MAAEC,EAAE,EAAEH,cAAc;MAAEC,YAAY,EAAZA;IAAY,CAAE;IAAC;EACnD;EAAC;AAAA,EAL2CL,UAAU;AAwBxD,IAAMQ,mBAAmB,GAAG,IAAIT,YAAY,CAACG,0BAA0B,CAAC;AAExE,IAAMO,2BAA2B,GAAG,sBAAsB;AAC1D,IAAMC,kCAAkC,GAAG,6BAA6B;AAExE,IAAIC,kBAAkB,GAAwB,IAAI;AAClD,IAAIC,yBAAyB,GAAwB,IAAI;AAEzD,OAAM,SAAUC,sBAAsB,CAACC,OAAmC;EACxE,IAAIH,kBAAkB,EAAE;IACtBA,kBAAkB,CAACI,MAAM,EAAE;IAC3BJ,kBAAkB,GAAG,IAAI;;EAE3B,IAAIC,yBAAyB,EAAE;IAC7BA,yBAAyB,CAACG,MAAM,EAAE;IAClCH,yBAAyB,GAAG,IAAI;;EAGlC,IAAIE,OAAO,EAAE;IACXH,kBAAkB,GAAGH,mBAAmB,CAACQ,WAAW,CAClDP,2BAA2B,EAC3B;MAAA;MAAA;QAAA;UAAA;YAAA;cAASF,EAAE,QAAFA,EAAE,EAAEF,YAAY,QAAZA,YAAY;cAAA,IAClBH,0BAA0B,CAACe,uBAAuB;gBAAA;gBAAA;cAAA;cACrDH,OAAO,CAACI,WAAW,oBAAnBJ,OAAO,CAACI,WAAW,CACjBX,EAAE,EACF,IAAIN,mBAAmB,CAAC,eAAe,EAAE,yBAAyB,CAAC,CACpE;cAAC;YAAA;cAAA;cAAA;cAAA,iCAKqBa,OAAO,CAACK,kBAAkB,CAACd,YAAY,CAAC;YAAA;cAAzDe,QAAQ;cAAA;cAAA,iCACRlB,0BAA0B,CAACe,uBAAuB,CAACV,EAAE,EAAEa,QAAQ,CAAC;YAAA;cACtEN,OAAO,CAACO,aAAa,oBAArBP,OAAO,CAACO,aAAa,CAAGd,EAAE,CAAC;cAAC;cAAA;YAAA;cAAA;cAAA;cAE5BO,OAAO,CAACI,WAAW,oBAAnBJ,OAAO,CAACI,WAAW,CAAGX,EAAE,cAAQ;YAAC;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAEpC,CACF;IAEDK,yBAAyB,GAAGJ,mBAAmB,CAACQ,WAAW,CACzDN,kCAAkC,EAClC;MAAA,IAAGH,EAAE,SAAFA,EAAE;QAAEF,YAAY,SAAZA,YAAY;MAAA,OACjBS,OAAO,CAACI,WAAW,oBAAnBJ,OAAO,CAACI,WAAW,CAAGX,EAAE,EAAE,IAAIJ,wBAAwB,CAACI,EAAE,EAAEF,YAAY,CAAC,CAAC;IAAA,EAC5E;;AAEL","names":["EventEmitter","CodedError","UnavailabilityError","NotificationsHandlerModule","NotificationTimeoutError","notificationId","notification","info","id","notificationEmitter","handleNotificationEventName","handleNotificationTimeoutEventName","handleSubscription","handleTimeoutSubscription","setNotificationHandler","handler","remove","addListener","handleNotificationAsync","handleError","handleNotification","behavior","handleSuccess"],"sourceRoot":"","sources":["../src/NotificationsHandler.ts"],"sourcesContent":["import { EventEmitter, Subscription, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationBehavior } from './Notifications.types';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\n\nexport class NotificationTimeoutError extends CodedError {\n  info: { notification: Notification; id: string };\n  constructor(notificationId: string, notification: Notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = { id: notificationId, notification };\n  }\n}\n\nexport type NotificationHandlingError = NotificationTimeoutError | Error;\n\nexport interface NotificationHandler {\n  handleNotification: (notification: Notification) => Promise<NotificationBehavior>;\n  handleSuccess?: (notificationId: string) => void;\n  handleError?: (notificationId: string, error: NotificationHandlingError) => void;\n}\n\ntype HandleNotificationEvent = {\n  id: string;\n  notification: Notification;\n};\n\ntype HandleNotificationTimeoutEvent = HandleNotificationEvent;\n\n// Web uses SyntheticEventEmitter\nconst notificationEmitter = new EventEmitter(NotificationsHandlerModule);\n\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\n\nlet handleSubscription: Subscription | null = null;\nlet handleTimeoutSubscription: Subscription | null = null;\n\nexport function setNotificationHandler(handler: NotificationHandler | null): void {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener<HandleNotificationEvent>(\n      handleNotificationEventName,\n      async ({ id, notification }) => {\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          handler.handleError?.(\n            id,\n            new UnavailabilityError('Notifications', 'handleNotificationAsync')\n          );\n          return;\n        }\n\n        try {\n          const behavior = await handler.handleNotification(notification);\n          await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          handler.handleSuccess?.(id);\n        } catch (error) {\n          handler.handleError?.(id, error);\n        }\n      }\n    );\n\n    handleTimeoutSubscription = notificationEmitter.addListener<HandleNotificationTimeoutEvent>(\n      handleNotificationTimeoutEventName,\n      ({ id, notification }) =>\n        handler.handleError?.(id, new NotificationTimeoutError(id, notification))\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}