{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from \"./utils/serialize\";\nimport { DOCUMENT_ID } from \"./FirestoreFieldPath\";\nvar OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN'\n};\nvar INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true\n};\nvar DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n\nvar FirestoreQueryModifiers = function () {\n  function FirestoreQueryModifiers() {\n    _classCallCheck(this, FirestoreQueryModifiers);\n\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _createClass(FirestoreQueryModifiers, [{\n    key: \"_copy\",\n    value: function _copy() {\n      var newInstance = new FirestoreQueryModifiers();\n      newInstance._limit = this._limit;\n      newInstance._limitToLast = this._limitToLast;\n      newInstance._filters = _toConsumableArray(this._filters);\n      newInstance._orders = _toConsumableArray(this._orders);\n      newInstance._type = this._type;\n      newInstance._startAt = this._startAt;\n      newInstance._startAfter = this._startAfter;\n      newInstance._endAt = this._endAt;\n      newInstance._endBefore = this._endBefore;\n      return newInstance;\n    }\n  }, {\n    key: \"filters\",\n    get: function get() {\n      return this._filters.map(function (f) {\n        return _objectSpread(_objectSpread({}, f), {}, {\n          fieldPath: f.fieldPath._toArray()\n        });\n      });\n    }\n  }, {\n    key: \"orders\",\n    get: function get() {\n      return this._orders;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = {};\n\n      if (this._limit) {\n        options.limit = this._limit;\n      }\n\n      if (this._limitToLast) {\n        options.limitToLast = this._limitToLast;\n      }\n\n      if (this._startAt) {\n        options.startAt = this._startAt;\n      }\n\n      if (this._startAfter) {\n        options.startAfter = this._startAfter;\n      }\n\n      if (this._endAt) {\n        options.endAt = this._endAt;\n      }\n\n      if (this._endBefore) {\n        options.endBefore = this._endBefore;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"setFieldsCursor\",\n    value: function setFieldsCursor(cursor, fields) {\n      this[\"_\" + cursor] = buildNativeArray(fields);\n      return this;\n    }\n  }, {\n    key: \"hasStart\",\n    value: function hasStart() {\n      return !!(this._startAt || this._startAfter);\n    }\n  }, {\n    key: \"hasEnd\",\n    value: function hasEnd() {\n      return !!(this._endAt || this._endBefore);\n    }\n  }, {\n    key: \"asCollectionGroupQuery\",\n    value: function asCollectionGroupQuery() {\n      this._type = 'collectionGroup';\n      return this;\n    }\n  }, {\n    key: \"isCollectionGroupQuery\",\n    value: function isCollectionGroupQuery() {\n      return this._type === 'collectionGroup';\n    }\n  }, {\n    key: \"isValidLimit\",\n    value: function isValidLimit(limit) {\n      return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      this._limitToLast = undefined;\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: \"isValidLimitToLast\",\n    value: function isValidLimitToLast(limit) {\n      return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"validatelimitToLast\",\n    value: function validatelimitToLast() {\n      if (this._limitToLast) {\n        if (!this._orders.length) {\n          throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n        }\n      }\n    }\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(_limitToLast) {\n      this._limit = undefined;\n      this._limitToLast = _limitToLast;\n      return this;\n    }\n  }, {\n    key: \"isValidOperator\",\n    value: function isValidOperator(operator) {\n      return !!OPERATORS[operator];\n    }\n  }, {\n    key: \"isEqualOperator\",\n    value: function isEqualOperator(operator) {\n      return OPERATORS[operator] === 'EQUAL';\n    }\n  }, {\n    key: \"isInOperator\",\n    value: function isInOperator(operator) {\n      return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' || OPERATORS[operator] === 'NOT_IN';\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var filter = {\n        fieldPath: fieldPath,\n        operator: OPERATORS[opStr],\n        value: generateNativeData(value, true)\n      };\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"validateWhere\",\n    value: function validateWhere() {\n      var hasInequality;\n      var hasNotEqual;\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        if (!INEQUALITY[filter.operator]) {\n          continue;\n        }\n\n        if (filter.operator === OPERATORS['!=']) {\n          if (hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n          }\n\n          hasNotEqual = true;\n        }\n\n        if (!hasInequality) {\n          hasInequality = filter;\n          continue;\n        }\n\n        if (INEQUALITY[filter.operator] && hasInequality) {\n          if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n            throw new Error(\"Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '\" + hasInequality.fieldPath._toPath() + \"' and '\" + filter.fieldPath._toPath() + \"'\");\n          }\n        }\n      }\n\n      var hasArrayContains;\n      var hasArrayContainsAny;\n      var hasIn;\n      var hasNotIn;\n\n      for (var _i = 0; _i < this._filters.length; _i++) {\n        var _filter = this._filters[_i];\n\n        if (_filter.operator === OPERATORS['array-contains']) {\n          if (hasArrayContains) {\n            throw new Error('Invalid query. Queries only support a single array-contains filter.');\n          }\n\n          hasArrayContains = true;\n        }\n\n        if (_filter.operator === OPERATORS['array-contains-any']) {\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\");\n          }\n\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\");\n          }\n\n          hasArrayContainsAny = true;\n        }\n\n        if (_filter.operator === OPERATORS.in) {\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\");\n          }\n\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n          }\n\n          hasIn = true;\n        }\n\n        if (_filter.operator === OPERATORS['not-in']) {\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n          }\n\n          if (hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\");\n          }\n\n          hasNotIn = true;\n        }\n      }\n    }\n  }, {\n    key: \"isValidDirection\",\n    value: function isValidDirection(directionStr) {\n      return !!DIRECTIONS[directionStr.toLowerCase()];\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      var order = {\n        fieldPath: fieldPath._toPath(),\n        direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n      };\n      this._orders = this._orders.concat(order);\n      return this;\n    }\n  }, {\n    key: \"validateOrderBy\",\n    value: function validateOrderBy() {\n      if (this._orders.length > 1) {\n        var orders = this._orders.map(function ($) {\n          return $.fieldPath;\n        });\n\n        var set = new Set(orders);\n\n        if (set.size !== orders.length) {\n          throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n        }\n      }\n\n      if (this._filters.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        var filterFieldPath = filter.fieldPath._toPath();\n\n        for (var k = 0; k < this._orders.length; k++) {\n          var order = this._orders[k];\n          var orderFieldPath = order.fieldPath;\n\n          if (filter.operator === OPERATORS['==']) {\n            if (filterFieldPath === orderFieldPath) {\n              throw new Error(\"Invalid query. Query.orderBy() parameter: \" + orderFieldPath + \" cannot be the same as your Query.where() fieldPath parameter: \" + filterFieldPath);\n            }\n          }\n\n          if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n            throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n          }\n\n          if (INEQUALITY[filter.operator]) {\n            if (filterFieldPath !== this._orders[0].fieldPath) {\n              throw new Error(\"Invalid query. Initial Query.orderBy() parameter: \" + orderFieldPath + \" has to be the same as the Query.where() fieldPath parameter(s): \" + filterFieldPath + \" when an inequality operator is invoked \");\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return FirestoreQueryModifiers;\n}();\n\nexport { FirestoreQueryModifiers as default };","map":{"version":3,"names":["isNumber","buildNativeArray","generateNativeData","DOCUMENT_ID","OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","NOT_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","newInstance","map","f","fieldPath","_toArray","options","limit","limitToLast","startAt","startAfter","endAt","endBefore","cursor","fields","Math","floor","length","Error","operator","opStr","value","filter","concat","hasInequality","hasNotEqual","i","_toPath","hasArrayContains","hasArrayContainsAny","hasIn","hasNotIn","directionStr","toLowerCase","order","direction","orders","$","set","Set","size","filterFieldPath","k","orderFieldPath"],"sources":["C:/DFMPC/DFMPC-Student-Placement-System/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\n\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f, fieldPath: f.fieldPath._toArray() }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return (\n      OPERATORS[operator] === 'IN' ||\n      OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' ||\n      OPERATORS[operator] === 'NOT_IN'\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n    let hasNotEqual;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n    let hasNotIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\",\n          );\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (hasNotEqual) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (this._filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}