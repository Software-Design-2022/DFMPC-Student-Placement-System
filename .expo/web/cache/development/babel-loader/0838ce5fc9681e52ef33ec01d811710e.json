{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, Platform } from 'expo-modules-core';\nfunction convertPermissionStatus(status) {\n  switch (status) {\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: true\n      };\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: false\n      };\n    default:\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false\n      };\n  }\n}\nfunction resolvePermissionAsync(_ref) {\n  var _navigator, _navigator$permission;\n  var shouldAsk, _window, _window$Notification, Notification, status, query;\n  return _regeneratorRuntime.async(function resolvePermissionAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          shouldAsk = _ref.shouldAsk;\n          if (Platform.isDOMAvailable) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt(\"return\", convertPermissionStatus('denied'));\n        case 3:\n          _window = window, _window$Notification = _window.Notification, Notification = _window$Notification === void 0 ? {} : _window$Notification;\n          if (!(typeof Notification.requestPermission !== 'undefined')) {\n            _context.next = 13;\n            break;\n          }\n          status = Notification.permission;\n          if (!shouldAsk) {\n            _context.next = 10;\n            break;\n          }\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(new Promise(function (resolve, reject) {\n            var _Notification$request, _Notification$request2;\n            var resolved = false;\n            function resolveOnce(status) {\n              if (!resolved) {\n                resolved = true;\n                resolve(status);\n              }\n            }\n            (_Notification$request = Notification.requestPermission(resolveOnce)) == null ? void 0 : (_Notification$request2 = _Notification$request.then(resolveOnce)) == null ? void 0 : _Notification$request2.catch(reject);\n          }));\n        case 9:\n          status = _context.sent;\n        case 10:\n          return _context.abrupt(\"return\", convertPermissionStatus(status));\n        case 13:\n          if (!(typeof navigator !== 'undefined' && (_navigator = navigator) != null && (_navigator$permission = _navigator.permissions) != null && _navigator$permission.query)) {\n            _context.next = 18;\n            break;\n          }\n          _context.next = 16;\n          return _regeneratorRuntime.awrap(navigator.permissions.query({\n            name: 'notifications'\n          }));\n        case 16:\n          query = _context.sent;\n          return _context.abrupt(\"return\", convertPermissionStatus(query.state));\n        case 18:\n          return _context.abrupt(\"return\", convertPermissionStatus('denied'));\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport default {\n  addListener: function addListener() {},\n  removeListeners: function removeListeners() {},\n  getPermissionsAsync: function getPermissionsAsync() {\n    return function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", resolvePermissionAsync({\n                shouldAsk: false\n              }));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  requestPermissionsAsync: function requestPermissionsAsync(request) {\n    return function _callee2() {\n      return _regeneratorRuntime.async(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", resolvePermissionAsync({\n                shouldAsk: true\n              }));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  }\n};","map":{"version":3,"mappings":";AAAA,SAASA,gBAAgB,EAAEC,QAAQ,QAAQ,mBAAmB;AAQ9D,SAASC,uBAAuB,CAC9BC,MAA0C;EAE1C,QAAQA,MAAM;IACZ,KAAK,SAAS;MACZ,OAAO;QACLA,MAAM,EAAEH,gBAAgB,CAACI,OAAO;QAChCC,OAAO,EAAE,OAAO;QAChBC,WAAW,EAAE,KAAK;QAClBC,OAAO,EAAE;OACV;IACH,KAAK,QAAQ;MACX,OAAO;QACLJ,MAAM,EAAEH,gBAAgB,CAACQ,MAAM;QAC/BH,OAAO,EAAE,OAAO;QAChBC,WAAW,EAAE,KAAK;QAClBC,OAAO,EAAE;OACV;IACH;MACE,OAAO;QACLJ,MAAM,EAAEH,gBAAgB,CAACS,YAAY;QACrCJ,OAAO,EAAE,OAAO;QAChBC,WAAW,EAAE,IAAI;QACjBC,OAAO,EAAE;OACV;EAAC;AAER;AAEA,SAAeG,sBAAsB;EAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UACnCC,SAAS,QAATA,SAAS;UAAA,IAIJV,QAAQ,CAACW,cAAc;YAAA;YAAA;UAAA;UAAA,iCACnBV,uBAAuB,CAAC,QAAQ,CAAC;QAAA;UAAA,UAGZW,MAAa,iCAAnCC,YAAY,EAAZA,YAAY,qCAAG,EAAE;UAAA,MACrB,OAAOA,YAAY,CAACC,iBAAiB,KAAK,WAAW;YAAA;YAAA;UAAA;UACnDZ,MAAM,GAAGW,YAAY,CAACE,UAAU;UAAA,KAChCL,SAAS;YAAA;YAAA;UAAA;UAAA;UAAA,iCACI,IAAIM,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAI;YAAA;YAC7C,IAAIC,QAAQ,GAAG,KAAK;YACpB,SAASC,WAAW,CAAClB,MAAc;cACjC,IAAI,CAACiB,QAAQ,EAAE;gBACbA,QAAQ,GAAG,IAAI;gBACfF,OAAO,CAACf,MAAM,CAAC;;YAEnB;YAEA,qCAAY,CAACY,iBAAiB,CAACM,WAAW,CAAC,+CAA3C,sBAA6CC,IAAI,CAACD,WAAW,CAAC,qBAA9D,uBAAgEE,KAAK,CAACJ,MAAM,CAAC;UAC/E,CAAC,CAAC;QAAA;UAVFhB,MAAM;QAAA;UAAA,iCAYDD,uBAAuB,CAACC,MAAM,CAAC;QAAA;UAAA,MAC7B,OAAOqB,SAAS,KAAK,WAAW,kBAAIA,SAAS,sCAAT,WAAWC,WAAW,aAAtB,sBAAwBC,KAAK;YAAA;YAAA;UAAA;UAAA;UAAA,iCAEtDF,SAAS,CAACC,WAAW,CAACC,KAAK,CAAC;YAAEC,IAAI,EAAE;UAAe,CAAE,CAAC;QAAA;UAApED,KAAK;UAAA,iCACJxB,uBAAuB,CAACwB,KAAK,CAACE,KAAK,CAAC;QAAA;UAAA,iCAGtC1B,uBAAuB,CAAC,QAAQ,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAG1C,eAAe;EACb2B,WAAW,EAAE,uBAAK,CAAE,CAAC;EACrBC,eAAe,EAAE,2BAAK,CAAE,CAAC;EACnBC,mBAAmB;IAAA;MAAA;QAAA;UAAA;YAAA;cAAA,kCAChBrB,sBAAsB,CAAC;gBAAEC,SAAS,EAAE;cAAK,CAAE,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EACrD,CAAC;EACKqB,uBAAuB,mCAC3BC,OAA6C;IAAA;MAAA;QAAA;UAAA;YAAA;cAAA,kCAEtCvB,sBAAsB,CAAC;gBAAEC,SAAS,EAAE;cAAI,CAAE,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EACpD;CACgC","names":["PermissionStatus","Platform","convertPermissionStatus","status","GRANTED","expires","canAskAgain","granted","DENIED","UNDETERMINED","resolvePermissionAsync","shouldAsk","isDOMAvailable","window","Notification","requestPermission","permission","Promise","resolve","reject","resolved","resolveOnce","then","catch","navigator","permissions","query","name","state","addListener","removeListeners","getPermissionsAsync","requestPermissionsAsync","request"],"sourceRoot":"","sources":["../src/NotificationPermissionsModule.ts"],"sourcesContent":["import { PermissionStatus, Platform } from 'expo-modules-core';\n\nimport {\n  NativeNotificationPermissionsRequest,\n  NotificationPermissionsStatus,\n} from './NotificationPermissions.types';\nimport { NotificationPermissionsModule } from './NotificationPermissionsModule.types';\n\nfunction convertPermissionStatus(\n  status?: NotificationPermission | 'prompt'\n): NotificationPermissionsStatus {\n  switch (status) {\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: true,\n      };\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: false,\n      };\n    default:\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n  }\n}\n\nasync function resolvePermissionAsync({\n  shouldAsk,\n}: {\n  shouldAsk: boolean;\n}): Promise<NotificationPermissionsStatus> {\n  if (!Platform.isDOMAvailable) {\n    return convertPermissionStatus('denied');\n  }\n\n  const { Notification = {} } = window as any;\n  if (typeof Notification.requestPermission !== 'undefined') {\n    let status = Notification.permission;\n    if (shouldAsk) {\n      status = await new Promise((resolve, reject) => {\n        let resolved = false;\n        function resolveOnce(status: string) {\n          if (!resolved) {\n            resolved = true;\n            resolve(status);\n          }\n        }\n        // Some browsers require a callback argument and some return a Promise\n        Notification.requestPermission(resolveOnce)?.then(resolveOnce)?.catch(reject);\n      });\n    }\n    return convertPermissionStatus(status);\n  } else if (typeof navigator !== 'undefined' && navigator?.permissions?.query) {\n    // TODO(Bacon): Support `push` in the future when it's stable.\n    const query = await navigator.permissions.query({ name: 'notifications' });\n    return convertPermissionStatus(query.state);\n  }\n  // Platforms like iOS Safari don't support Notifications so return denied.\n  return convertPermissionStatus('denied');\n}\n\nexport default {\n  addListener: () => {},\n  removeListeners: () => {},\n  async getPermissionsAsync(): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: false });\n  },\n  async requestPermissionsAsync(\n    request: NativeNotificationPermissionsRequest\n  ): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: true });\n  },\n} as NotificationPermissionsModule;\n"]},"metadata":{},"sourceType":"module"}