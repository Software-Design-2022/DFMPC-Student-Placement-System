{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { hasOwnProperty, isArray, isBoolean, isFunction, isObject, isString, isUndefined } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from \"../FirestoreFieldPath\";\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  var pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\nexport function parseUpdateArgs(args) {\n  var data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n\n    var _args = _slicedToArray(args, 1);\n\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(\"argument at index \" + i + \" must be a string or FieldPath\");\n      }\n    }\n  }\n\n  return data;\n}\nexport function parseSetOptions(options) {\n  var out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (var i = 0; i < options.mergeFields.length; i++) {\n      var field = options.mergeFields[i];\n\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\"'options.mergeFields' all fields must be of type string or FieldPath, but the value at index \" + i + \" was \" + typeof field);\n      }\n\n      var path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(\"'options.mergeFields' \" + e.message);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  var NOOP = function NOOP() {};\n\n  var snapshotListenOptions = {};\n  var callback = NOOP;\n  var onError = NOOP;\n  var onNext = NOOP;\n\n  if (isFunction(args[0])) {\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      callback = args[0];\n    }\n  }\n\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    var observer = args[0];\n\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n\n    if (isFunction(args[1])) {\n      if (isFunction(args[2])) {\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      var _observer = args[1];\n\n      if (_observer.error) {\n        onError = isFunction(_observer.error) ? _observer.error.bind(_observer) : _observer.error;\n      }\n\n      if (_observer.next) {\n        onNext = isFunction(_observer.next) ? _observer.next.bind(_observer) : _observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return {\n    snapshotListenOptions: snapshotListenOptions,\n    callback: callback,\n    onNext: onNext,\n    onError: onError\n  };\n}","map":{"version":3,"names":["hasOwnProperty","isArray","isBoolean","isFunction","isObject","isString","isUndefined","FirestoreFieldPath","fromDotSeparatedString","extractFieldPathData","data","segmenets","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","i","key","value","_toPath","parseSetOptions","options","out","merge","mergeFields","field","path","e","message","push","isPartialObserver","input","next","error","complete","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","observer","bind","includeMetadataChanges"],"sources":["C:/DFMPC/DFMPC-Student-Placement-System/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges =\n      args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}