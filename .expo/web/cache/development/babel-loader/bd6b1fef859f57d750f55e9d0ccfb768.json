{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TabBarItem from \"./TabBarItem\";\nimport TabBarIndicator from \"./TabBarIndicator\";\nvar Separator = function Separator(_ref) {\n  var width = _ref.width;\n  return React.createElement(View, {\n    style: {\n      width: width\n    }\n  });\n};\nvar TabBar = function (_React$Component) {\n  _inherits(TabBar, _React$Component);\n  var _super = _createSuper(TabBar);\n  function TabBar() {\n    var _this;\n    _classCallCheck(this, TabBar);\n    _this = _super.apply(this, arguments);\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      layout: {\n        width: 0,\n        height: 0\n      },\n      tabWidths: {}\n    });\n    _defineProperty(_assertThisInitialized(_this), \"measuredTabWidths\", {});\n    _defineProperty(_assertThisInitialized(_this), \"scrollAmount\", new Animated.Value(0));\n    _defineProperty(_assertThisInitialized(_this), \"flatListRef\", React.createRef());\n    _defineProperty(_assertThisInitialized(_this), \"getFlattenedTabWidth\", function (style) {\n      var tabStyle = StyleSheet.flatten(style);\n      return tabStyle ? tabStyle.width : undefined;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getComputedTabWidth\", function (index, layout, routes, scrollEnabled, tabWidths, flattenedWidth) {\n      if (flattenedWidth === 'auto') {\n        return tabWidths[routes[index].key] || 0;\n      }\n      switch (typeof flattenedWidth) {\n        case 'number':\n          return flattenedWidth;\n        case 'string':\n          if (flattenedWidth.endsWith('%')) {\n            var width = parseFloat(flattenedWidth);\n            if (Number.isFinite(width)) {\n              return layout.width * (width / 100);\n            }\n          }\n      }\n      if (scrollEnabled) {\n        return layout.width / 5 * 2;\n      }\n      return layout.width / routes.length;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getMaxScrollDistance\", function (tabBarWidth, layoutWidth) {\n      return tabBarWidth - layoutWidth;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getTabBarWidth\", function (props, state) {\n      var layout = state.layout,\n        tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n        tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      return routes.reduce(function (acc, _, i) {\n        var _props$gap;\n        return acc + (i > 0 ? (_props$gap = props.gap) != null ? _props$gap : 0 : 0) + _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n      }, 0);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"normalizeScrollValue\", function (props, state, value) {\n      var layout = state.layout;\n      var tabBarWidth = _this.getTabBarWidth(props, state);\n      var maxDistance = _this.getMaxScrollDistance(tabBarWidth, layout.width);\n      var scrollValue = Math.max(Math.min(value, maxDistance), 0);\n      if (Platform.OS === 'android' && I18nManager.isRTL) {\n        return maxDistance - scrollValue;\n      }\n      return scrollValue;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getScrollAmount\", function (props, state, index) {\n      var layout = state.layout,\n        tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n        tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      var centerDistance = Array.from({\n        length: index + 1\n      }).reduce(function (total, _, i) {\n        var _props$gap2, _props$gap3;\n        var tabWidth = _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n\n        return total + (index === i ? (tabWidth + ((_props$gap2 = props.gap) != null ? _props$gap2 : 0)) / 2 : tabWidth + ((_props$gap3 = props.gap) != null ? _props$gap3 : 0));\n      }, 0);\n      var scrollAmount = centerDistance - layout.width / 2;\n      return _this.normalizeScrollValue(props, state, scrollAmount);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"resetScroll\", function (index) {\n      if (_this.props.scrollEnabled) {\n        var _this$flatListRef$cur;\n        (_this$flatListRef$cur = _this.flatListRef.current) === null || _this$flatListRef$cur === void 0 ? void 0 : _this$flatListRef$cur.scrollToOffset({\n          offset: _this.getScrollAmount(_this.props, _this.state, index),\n          animated: true\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleLayout\", function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        height = _e$nativeEvent$layout.height,\n        width = _e$nativeEvent$layout.width;\n      if (_this.state.layout.width === width && _this.state.layout.height === height) {\n        return;\n      }\n      _this.setState({\n        layout: {\n          height: height,\n          width: width\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getTranslateX\", function (scrollAmount, maxScrollDistance) {\n      return Animated.multiply(Platform.OS === 'android' && I18nManager.isRTL ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1)) : scrollAmount, I18nManager.isRTL ? 1 : -1);\n    });\n    return _this;\n  }\n  _createClass(TabBar, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var navigationState = this.props.navigationState;\n      var _this$state = this.state,\n        layout = _this$state.layout,\n        tabWidths = _this$state.tabWidths;\n      if (prevProps.navigationState.routes.length !== navigationState.routes.length || prevProps.navigationState.index !== navigationState.index || prevState.layout.width !== layout.width || prevState.tabWidths !== tabWidths) {\n        if (this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' && !(layout.width && navigationState.routes.every(function (r) {\n          return typeof tabWidths[r.key] === 'number';\n        }))) {\n          return;\n        }\n        this.resetScroll(navigationState.index);\n      }\n    }\n  }, {\n    key: \"render\",\n    value:\n\n    function render() {\n      var _this2 = this;\n      var _this$props = this.props,\n        position = _this$props.position,\n        navigationState = _this$props.navigationState,\n        jumpTo = _this$props.jumpTo,\n        scrollEnabled = _this$props.scrollEnabled,\n        bounces = _this$props.bounces,\n        getAccessibilityLabel = _this$props.getAccessibilityLabel,\n        getAccessible = _this$props.getAccessible,\n        getLabelText = _this$props.getLabelText,\n        getTestID = _this$props.getTestID,\n        renderBadge = _this$props.renderBadge,\n        renderIcon = _this$props.renderIcon,\n        renderLabel = _this$props.renderLabel,\n        renderTabBarItem = _this$props.renderTabBarItem,\n        activeColor = _this$props.activeColor,\n        inactiveColor = _this$props.inactiveColor,\n        pressColor = _this$props.pressColor,\n        pressOpacity = _this$props.pressOpacity,\n        onTabPress = _this$props.onTabPress,\n        onTabLongPress = _this$props.onTabLongPress,\n        tabStyle = _this$props.tabStyle,\n        labelStyle = _this$props.labelStyle,\n        indicatorStyle = _this$props.indicatorStyle,\n        contentContainerStyle = _this$props.contentContainerStyle,\n        style = _this$props.style,\n        indicatorContainerStyle = _this$props.indicatorContainerStyle,\n        _this$props$gap = _this$props.gap,\n        gap = _this$props$gap === void 0 ? 0 : _this$props$gap;\n      var _this$state2 = this.state,\n        layout = _this$state2.layout,\n        tabWidths = _this$state2.tabWidths;\n      var routes = navigationState.routes;\n      var isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n      var tabBarWidth = this.getTabBarWidth(this.props, this.state);\n      var separatorsWidth = Math.max(0, routes.length - 1) * gap;\n      var separatorPercent = separatorsWidth / tabBarWidth * 100;\n      var tabBarWidthPercent = routes.length * 40 + \"%\";\n      var translateX = this.getTranslateX(this.scrollAmount, this.getMaxScrollDistance(tabBarWidth, layout.width));\n      return React.createElement(Animated.View, {\n        onLayout: this.handleLayout,\n        style: [styles.tabBar, style]\n      }, React.createElement(Animated.View, {\n        pointerEvents: \"none\",\n        style: [styles.indicatorContainer, scrollEnabled ? {\n          transform: [{\n            translateX: translateX\n          }]\n        } : null, tabBarWidth > separatorsWidth ? {\n          width: tabBarWidth - separatorsWidth\n        } : scrollEnabled ? {\n          width: tabBarWidthPercent\n        } : null, indicatorContainerStyle]\n      }, this.props.renderIndicator({\n        position: position,\n        layout: layout,\n        navigationState: navigationState,\n        jumpTo: jumpTo,\n        width: isWidthDynamic ? 'auto' : (100 - separatorPercent) / routes.length + \"%\",\n        style: indicatorStyle,\n        getTabWidth: function getTabWidth(i) {\n          return _this2.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this2.getFlattenedTabWidth(tabStyle));\n        },\n        gap: gap\n      })), React.createElement(View, {\n        style: styles.scroll\n      }, React.createElement(Animated.FlatList, {\n        data: routes,\n        keyExtractor: function keyExtractor(item) {\n          return item.key;\n        },\n        horizontal: true,\n        accessibilityRole: \"tablist\",\n        keyboardShouldPersistTaps: \"handled\",\n        scrollEnabled: scrollEnabled,\n        bounces: bounces,\n        alwaysBounceHorizontal: false,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        showsVerticalScrollIndicator: false,\n        automaticallyAdjustContentInsets: false,\n        overScrollMode: \"never\",\n        contentContainerStyle: [styles.tabContent, scrollEnabled ? {\n          width: tabBarWidth > separatorsWidth ? tabBarWidth : tabBarWidthPercent\n        } : styles.container, contentContainerStyle],\n        scrollEventThrottle: 16,\n        renderItem: function renderItem(_ref2) {\n          var route = _ref2.item,\n            index = _ref2.index;\n          var props = {\n            key: route.key,\n            position: position,\n            route: route,\n            navigationState: navigationState,\n            getAccessibilityLabel: getAccessibilityLabel,\n            getAccessible: getAccessible,\n            getLabelText: getLabelText,\n            getTestID: getTestID,\n            renderBadge: renderBadge,\n            renderIcon: renderIcon,\n            renderLabel: renderLabel,\n            activeColor: activeColor,\n            inactiveColor: inactiveColor,\n            pressColor: pressColor,\n            pressOpacity: pressOpacity,\n            onLayout: isWidthDynamic ? function (e) {\n              _this2.measuredTabWidths[route.key] = e.nativeEvent.layout.width;\n\n              if (routes.every(function (r) {\n                return typeof _this2.measuredTabWidths[r.key] === 'number';\n              })) {\n                _this2.setState({\n                  tabWidths: _objectSpread({}, _this2.measuredTabWidths)\n                });\n              }\n            } : undefined,\n            onPress: function onPress() {\n              var event = {\n                route: route,\n                defaultPrevented: false,\n                preventDefault: function preventDefault() {\n                  event.defaultPrevented = true;\n                }\n              };\n              onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n              if (event.defaultPrevented) {\n                return;\n              }\n              _this2.props.jumpTo(route.key);\n            },\n            onLongPress: function onLongPress() {\n              return onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({\n                route: route\n              });\n            },\n            labelStyle: labelStyle,\n            style: [tabStyle,\n            _this2.getFlattenedTabWidth(tabStyle) === undefined && {\n              width: _this2.getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, _this2.getFlattenedTabWidth(tabStyle))\n            }]\n          };\n          return React.createElement(React.Fragment, {\n            key: route.key\n          }, gap > 0 && index > 0 ? React.createElement(Separator, {\n            width: gap\n          }) : null, renderTabBarItem ? renderTabBarItem(props) : React.createElement(TabBarItem, props));\n        },\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: this.scrollAmount\n            }\n          }\n        }], {\n          useNativeDriver: true\n        }),\n        ref: this.flatListRef\n      })));\n    }\n  }]);\n  return TabBar;\n}(React.Component);\nexport { TabBar as default };\n_defineProperty(TabBar, \"defaultProps\", {\n  getLabelText: function getLabelText(_ref3) {\n    var route = _ref3.route;\n    return route.title;\n  },\n  getAccessible: function getAccessible(_ref4) {\n    var route = _ref4.route;\n    return typeof route.accessible !== 'undefined' ? route.accessible : true;\n  },\n  getAccessibilityLabel: function getAccessibilityLabel(_ref5) {\n    var route = _ref5.route;\n    return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n  },\n  getTestID: function getTestID(_ref6) {\n    var route = _ref6.route;\n    return route.testID;\n  },\n  renderIndicator: function renderIndicator(props) {\n    return React.createElement(TabBarIndicator, props);\n  },\n  gap: 0\n});\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0\n    },\n    zIndex: 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"mappings":"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","names":["React","TabBarItem","TabBarIndicator","Separator","_ref","width","View","style","TabBar","_defineProperty","layout","height","tabWidths","Animated","Value","createRef","tabStyle","StyleSheet","flatten","undefined","index","routes","scrollEnabled","flattenedWidth","key","endsWith","parseFloat","Number","isFinite","length","tabBarWidth","layoutWidth","props","state","navigationState","reduce","acc","_","i","gap","getComputedTabWidth","getFlattenedTabWidth","value","getTabBarWidth","maxDistance","getMaxScrollDistance","scrollValue","Math","max","min","Platform","OS","I18nManager","isRTL","centerDistance","Array","from","total","tabWidth","scrollAmount","normalizeScrollValue","flatListRef","current","scrollToOffset","offset","getScrollAmount","animated","e","nativeEvent","setState","maxScrollDistance","multiply","add","componentDidUpdate","prevProps","prevState","every","r","resetScroll","render","position","jumpTo","bounces","getAccessibilityLabel","getAccessible","getLabelText","getTestID","renderBadge","renderIcon","renderLabel","renderTabBarItem","activeColor","inactiveColor","pressColor","pressOpacity","onTabPress","onTabLongPress","labelStyle","indicatorStyle","contentContainerStyle","indicatorContainerStyle","isWidthDynamic","separatorsWidth","separatorPercent","tabBarWidthPercent","translateX","getTranslateX","onLayout","handleLayout","styles","tabBar","pointerEvents","indicatorContainer","transform","renderIndicator","getTabWidth","scroll","FlatList","data","keyExtractor","item","horizontal","accessibilityRole","keyboardShouldPersistTaps","alwaysBounceHorizontal","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","automaticallyAdjustContentInsets","overScrollMode","tabContent","container","scrollEventThrottle","renderItem","route","_ref2","measuredTabWidths","onPress","event","defaultPrevented","preventDefault","onLongPress","Fragment","onScroll","contentOffset","x","useNativeDriver","ref","Component","_ref3","title","_ref4","accessible","_ref5","accessibilityLabel","_ref6","testID","create","flex","overflow","select","default","web","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","zIndex","flexDirection","flexWrap","top","left","right","bottom"],"sources":["TabBar.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  StyleProp,\n  ViewStyle,\n  TextStyle,\n  LayoutChangeEvent,\n  I18nManager,\n  Platform,\n  FlatList,\n  ListRenderItemInfo,\n} from 'react-native';\nimport TabBarItem, { Props as TabBarItemProps } from './TabBarItem';\nimport TabBarIndicator, { Props as IndicatorProps } from './TabBarIndicator';\nimport type {\n  Route,\n  Scene,\n  SceneRendererProps,\n  NavigationState,\n  Layout,\n  Event,\n} from './types';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText: (scene: Scene<T>) => string | undefined;\n  getAccessible: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel: (scene: Scene<T>) => string | undefined;\n  getTestID: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n  gap?: number;\n};\n\ntype State = {\n  layout: Layout;\n  tabWidths: { [key: string]: number };\n};\n\nconst Separator = ({ width }: { width: number }) => {\n  return <View style={{ width }} />;\n};\n\nexport default class TabBar<T extends Route> extends React.Component<\n  Props<T>,\n  State\n> {\n  static defaultProps = {\n    getLabelText: ({ route }: Scene<Route>) => route.title,\n    getAccessible: ({ route }: Scene<Route>) =>\n      typeof route.accessible !== 'undefined' ? route.accessible : true,\n    getAccessibilityLabel: ({ route }: Scene<Route>) =>\n      typeof route.accessibilityLabel === 'string'\n        ? route.accessibilityLabel\n        : typeof route.title === 'string'\n        ? route.title\n        : undefined,\n    getTestID: ({ route }: Scene<Route>) => route.testID,\n    renderIndicator: (props: IndicatorProps<Route>) => (\n      <TabBarIndicator {...props} />\n    ),\n    gap: 0,\n  };\n\n  state: State = {\n    layout: { width: 0, height: 0 },\n    tabWidths: {},\n  };\n\n  componentDidUpdate(prevProps: Props<T>, prevState: State) {\n    const { navigationState } = this.props;\n    const { layout, tabWidths } = this.state;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        navigationState.routes.length ||\n      prevProps.navigationState.index !== navigationState.index ||\n      prevState.layout.width !== layout.width ||\n      prevState.tabWidths !== tabWidths\n    ) {\n      if (\n        this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' &&\n        !(\n          layout.width &&\n          navigationState.routes.every(\n            (r) => typeof tabWidths[r.key] === 'number'\n          )\n        )\n      ) {\n        // When tab width is dynamic, only adjust the scroll once we have all tab widths and layout\n        return;\n      }\n\n      this.resetScroll(navigationState.index);\n    }\n  }\n\n  // to store the layout.width of each tab\n  // when all onLayout's are fired, this would be set in state\n  private measuredTabWidths: { [key: string]: number } = {};\n\n  private scrollAmount = new Animated.Value(0);\n\n  private flatListRef = React.createRef<FlatList>();\n\n  private getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n    const tabStyle = StyleSheet.flatten(style);\n\n    return tabStyle ? tabStyle.width : undefined;\n  };\n\n  private getComputedTabWidth = (\n    index: number,\n    layout: Layout,\n    routes: Route[],\n    scrollEnabled: boolean | undefined,\n    tabWidths: { [key: string]: number },\n    flattenedWidth: string | number | undefined\n  ) => {\n    if (flattenedWidth === 'auto') {\n      return tabWidths[routes[index].key] || 0;\n    }\n\n    switch (typeof flattenedWidth) {\n      case 'number':\n        return flattenedWidth;\n      case 'string':\n        if (flattenedWidth.endsWith('%')) {\n          const width = parseFloat(flattenedWidth);\n          if (Number.isFinite(width)) {\n            return layout.width * (width / 100);\n          }\n        }\n    }\n\n    if (scrollEnabled) {\n      return (layout.width / 5) * 2;\n    }\n    return layout.width / routes.length;\n  };\n\n  private getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n    tabBarWidth - layoutWidth;\n\n  private getTabBarWidth = (props: Props<T>, state: State) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    return routes.reduce<number>(\n      (acc, _, i) =>\n        acc +\n        (i > 0 ? props.gap ?? 0 : 0) +\n        this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        ),\n      0\n    );\n  };\n\n  private normalizeScrollValue = (\n    props: Props<T>,\n    state: State,\n    value: number\n  ) => {\n    const { layout } = state;\n    const tabBarWidth = this.getTabBarWidth(props, state);\n    const maxDistance = this.getMaxScrollDistance(tabBarWidth, layout.width);\n    const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n    if (Platform.OS === 'android' && I18nManager.isRTL) {\n      // On Android, scroll value is not applied in reverse in RTL\n      // so we need to manually adjust it to apply correct value\n      return maxDistance - scrollValue;\n    }\n\n    return scrollValue;\n  };\n\n  private getScrollAmount = (props: Props<T>, state: State, index: number) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    const centerDistance = Array.from({ length: index + 1 }).reduce<number>(\n      (total, _, i) => {\n        const tabWidth = this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        );\n\n        // To get the current index centered we adjust scroll amount by width of indexes\n        // 0 through (i - 1) and add half the width of current index i\n        return (\n          total +\n          (index === i\n            ? (tabWidth + (props.gap ?? 0)) / 2\n            : tabWidth + (props.gap ?? 0))\n        );\n      },\n      0\n    );\n\n    const scrollAmount = centerDistance - layout.width / 2;\n\n    return this.normalizeScrollValue(props, state, scrollAmount);\n  };\n\n  private resetScroll = (index: number) => {\n    if (this.props.scrollEnabled) {\n      this.flatListRef.current?.scrollToOffset({\n        offset: this.getScrollAmount(this.props, this.state, index),\n        animated: true,\n      });\n    }\n  };\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    if (\n      this.state.layout.width === width &&\n      this.state.layout.height === height\n    ) {\n      return;\n    }\n\n    this.setState({\n      layout: {\n        height,\n        width,\n      },\n    });\n  };\n\n  private getTranslateX = (\n    scrollAmount: Animated.Value,\n    maxScrollDistance: number\n  ) =>\n    Animated.multiply(\n      Platform.OS === 'android' && I18nManager.isRTL\n        ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n        : scrollAmount,\n      I18nManager.isRTL ? 1 : -1\n    );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      jumpTo,\n      scrollEnabled,\n      bounces,\n      getAccessibilityLabel,\n      getAccessible,\n      getLabelText,\n      getTestID,\n      renderBadge,\n      renderIcon,\n      renderLabel,\n      renderTabBarItem,\n      activeColor,\n      inactiveColor,\n      pressColor,\n      pressOpacity,\n      onTabPress,\n      onTabLongPress,\n      tabStyle,\n      labelStyle,\n      indicatorStyle,\n      contentContainerStyle,\n      style,\n      indicatorContainerStyle,\n      gap = 0,\n    } = this.props;\n    const { layout, tabWidths } = this.state;\n    const { routes } = navigationState;\n\n    const isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n    const tabBarWidth = this.getTabBarWidth(this.props, this.state);\n    const separatorsWidth = Math.max(0, routes.length - 1) * gap;\n    const separatorPercent = (separatorsWidth / tabBarWidth) * 100;\n\n    const tabBarWidthPercent = `${routes.length * 40}%`;\n    const translateX = this.getTranslateX(\n      this.scrollAmount,\n      this.getMaxScrollDistance(tabBarWidth, layout.width)\n    );\n\n    return (\n      <Animated.View\n        onLayout={this.handleLayout}\n        style={[styles.tabBar, style]}\n      >\n        <Animated.View\n          pointerEvents=\"none\"\n          style={[\n            styles.indicatorContainer,\n            scrollEnabled ? { transform: [{ translateX }] as any } : null,\n            tabBarWidth > separatorsWidth\n              ? { width: tabBarWidth - separatorsWidth }\n              : scrollEnabled\n              ? { width: tabBarWidthPercent }\n              : null,\n            indicatorContainerStyle,\n          ]}\n        >\n          {this.props.renderIndicator({\n            position,\n            layout,\n            navigationState,\n            jumpTo,\n            width: isWidthDynamic\n              ? 'auto'\n              : `${(100 - separatorPercent) / routes.length}%`,\n            style: indicatorStyle,\n            getTabWidth: (i: number) =>\n              this.getComputedTabWidth(\n                i,\n                layout,\n                routes,\n                scrollEnabled,\n                tabWidths,\n                this.getFlattenedTabWidth(tabStyle)\n              ),\n            gap,\n          })}\n        </Animated.View>\n        <View style={styles.scroll}>\n          <Animated.FlatList\n            data={routes as Animated.WithAnimatedValue<T>[]}\n            keyExtractor={(item) => item.key}\n            horizontal\n            accessibilityRole=\"tablist\"\n            keyboardShouldPersistTaps=\"handled\"\n            scrollEnabled={scrollEnabled}\n            bounces={bounces}\n            alwaysBounceHorizontal={false}\n            scrollsToTop={false}\n            showsHorizontalScrollIndicator={false}\n            showsVerticalScrollIndicator={false}\n            automaticallyAdjustContentInsets={false}\n            overScrollMode=\"never\"\n            contentContainerStyle={[\n              styles.tabContent,\n              scrollEnabled\n                ? {\n                    width:\n                      tabBarWidth > separatorsWidth\n                        ? tabBarWidth\n                        : tabBarWidthPercent,\n                  }\n                : styles.container,\n              contentContainerStyle,\n            ]}\n            scrollEventThrottle={16}\n            renderItem={({ item: route, index }: ListRenderItemInfo<T>) => {\n              const props: TabBarItemProps<T> & { key: string } = {\n                key: route.key,\n                position: position,\n                route: route,\n                navigationState: navigationState,\n                getAccessibilityLabel: getAccessibilityLabel,\n                getAccessible: getAccessible,\n                getLabelText: getLabelText,\n                getTestID: getTestID,\n                renderBadge: renderBadge,\n                renderIcon: renderIcon,\n                renderLabel: renderLabel,\n                activeColor: activeColor,\n                inactiveColor: inactiveColor,\n                pressColor: pressColor,\n                pressOpacity: pressOpacity,\n                onLayout: isWidthDynamic\n                  ? (e) => {\n                      this.measuredTabWidths[route.key] =\n                        e.nativeEvent.layout.width;\n\n                      // When we have measured widths for all of the tabs, we should updates the state\n                      // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n                      if (\n                        routes.every(\n                          (r) =>\n                            typeof this.measuredTabWidths[r.key] === 'number'\n                        )\n                      ) {\n                        this.setState({\n                          tabWidths: { ...this.measuredTabWidths },\n                        });\n                      }\n                    }\n                  : undefined,\n                onPress: () => {\n                  const event: Scene<T> & Event = {\n                    route,\n                    defaultPrevented: false,\n                    preventDefault: () => {\n                      event.defaultPrevented = true;\n                    },\n                  };\n\n                  onTabPress?.(event);\n\n                  if (event.defaultPrevented) {\n                    return;\n                  }\n\n                  this.props.jumpTo(route.key);\n                },\n                onLongPress: () => onTabLongPress?.({ route }),\n                labelStyle: labelStyle,\n                style: [\n                  tabStyle,\n                  // Calculate the deafult width for tab for FlatList to work.\n                  this.getFlattenedTabWidth(tabStyle) === undefined && {\n                    width: this.getComputedTabWidth(\n                      index,\n                      layout,\n                      routes,\n                      scrollEnabled,\n                      tabWidths,\n                      this.getFlattenedTabWidth(tabStyle)\n                    ),\n                  },\n                ],\n              };\n\n              return (\n                <React.Fragment key={route.key}>\n                  {gap > 0 && index > 0 ? <Separator width={gap} /> : null}\n                  {renderTabBarItem ? (\n                    renderTabBarItem(props)\n                  ) : (\n                    <TabBarItem {...props} />\n                  )}\n                </React.Fragment>\n              );\n            }}\n            onScroll={Animated.event(\n              [\n                {\n                  nativeEvent: {\n                    contentOffset: { x: this.scrollAmount },\n                  },\n                },\n              ],\n              { useNativeDriver: true }\n            )}\n            ref={this.flatListRef}\n          />\n        </View>\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0,\n    },\n    zIndex: 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}